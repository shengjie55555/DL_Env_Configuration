# Learn C++ from Scratch
## array
1. 定义数组后，sizeof(arr)可以统计数组所占内存空间，但是如果作为函数的实参传入时，只是一个64bit的地址，不能用来统计数组所占内存空间。
2. 数组作为函数的形参或者返回值时：  

| 数组类型  | 定义                              | 调用            | 备注                          |
|-----------|-----------------------------------|-----------------|----------------------------|
| 1d        | void sort(int a[10]);             | sort(b);        | a和b为长度相同的1d数组        |
| 1d        | void sort(int a[], int size);     | sort(b, 10);    | b为1d数组                   |
| 2d        | void sort(int a[10][10]);         | sort(b);        | a和b为长度相同的2d数组        |
| 2d        | void sort(int a[][10], int row);  | sort(b, 10);    | b为2d数组，行数可变           |
| 2d        | void sort(int a[], int size);     | sort(*b, 100);  | a和b为2d数组，可转换为1d数组   |

## 指针
1. 空指针：指针变量指向内存中编号为0的空间。空指针指向的内存是不可以访问的，可以正常编译，执行会出问题。
2. 野指针：指针变量指向非法的内存空间。比如手动将一个地址赋值给指针变量。
3. const修饰指针：const修饰距离它最近的，const int *a, 那么指向int变量的值不能变，
   
| 常量指针：const修饰变量    | const int *a;         | 指针可以指向别的变量，但是不能改变指向变量的值。  |
|-------------------------|-----------------------|-------------------------------------------|
| 指针常量：const修饰指针    | int * const a;        | 指针指向不能变，但是指针指向变量的值可以变。      |
| const既修饰指针又修饰变量  | const int * const a;  | 指针指向的变量不能变，指向的变量的值也不能变。    |
4. 指针与数组：int a[4][4]; 那么a[1]与*(a+1)与&a[1][0]与&a[1]都是第一行的首地址。
   
## 引用
1. int &b = a; // b是a的别名。
2. int &b; // 错误，引用必须初始化，int &b = a; 初始化后不可以改变。
3. void swap(int &a, int &b); // 引用传递时，可以改变实参，本质上a是对传入实参的引用。 
4. 引用的本质在C++内部实现是一个指针常量：int &ref = a; ref = 10; 等同于int* const ref = &a; *ref = 10; 
5. void swap(const int &a, const int &b); // 用来修饰形参，防止误操作改变实参。 

## 结构体
1. 定义结构体的成员时，不能指定成员的存储类型为auto、register、extern，这是因为系统不为结构体类型分配任何存储空间，但是可以指定成员的存储类型为static。 
2. 定义结构体时: struct 数据类型 {int age; char[20] name;}；struct不可省略，创建变量可以省略。 
3. 结构体数组：结构体类型名 数组名[size] = {{}, {}, {}}; 
4. 结构体指针：struct_type *p = struct_valiable; 这时候用->访问结构体属性。 
   
## C++核心编程
1. C++程序在执行时，将内存大方向划分为4个区域： 
   1. 代码区：存放函数体的二进制代码，由操作系统进行管理； 
   2. 全局区：存放全局变量、静态变量和常量； 
   3. 栈区：由编译器自动分配释放，存放函数的参数值、局部变量等； 
   4. 堆区：由程序员分配和释放（new和delete），若程序员不释放，程序结束时由操作系统回收。 

| int* a = new int(10);    | delete a;      |
|--------------------------|----------------|
| int* arr = new int[10];  | delete[] arr;  |

2. 函数提高
   1. void func(int a, int b = 10; int c = 10;); // 函数形参列表可以有默认值，出现默认值的变量必须排到末尾，函数声明时有默认值，函数实现时就不能再写默认值。
   2. void func(int a, int); // 函数占位参数，调用时必须填补该位置
   3. 函数重载： 
      1. 同一个作用域； 
      2. 函数名称相同； 
      3. 函数参数类型不同、个数不同或者顺序不同；
      4. 函数的返回值不可以作为函数重载的条件，调用函数时确保**入口不同**；
      5. 函数形参有默认值和函数重载在调用时可能产生歧义。 
   
| void func();          | void func(int a);            |
|-----------------------|------------------------------|
| void func(double a);  | void func(int a, double b);  |

3. 类和对象 
   1. 封装的意义：将属性和方法作为一个整体；将属性和方法加以权限控制。struct默认权限为public，class默认权限为private 
   2. 构造函数：类名() {} 
      1. 没有返回值也不用写void；
      2. 函数名称和类名相同； 
      3. 构造函数可以有参数，因此会发生重载;
      4. 程序在调用对象时会自动调用构造函数，无需手动调用，而且只调用一次;
      5. 默认情况下，C++编译器会提供默认构造函数、默认拷贝函数（浅拷贝）和默认析构函数。（1）如果用户定义有参构造函数，C++不提供默认无参数构造函数，但是会提供默认拷贝构造函数；（2）如果用户自定义拷贝构造函数，C++不再提供其他构造函数，这时候如果没有定义其他构造函数，Cube cube(10); 和 Cube cube；都会出错;
      6. 深拷贝和浅拷贝：如果类的属性中有指针，初始化后，指针会指向某个内存空间，浅拷贝只会将这个内存空间的地址赋值给新对象的指针，而不会重新在堆区开辟空间，这会导致两个问题：（1）如果原来的对象是函数内部作用域的局部变量，退出函数后，该变量会销毁，那么新对象指针指向的内存空间也被释放了；（2）如果析构函数里面用delete释放堆区空间，浅拷贝会导致多次释放同一个空间;
      7. 初始化列表：构造函数(int a, int b) : m_a(a), m_b(b){…} //其中m_a, m_b为类的属性;
      8. B类成员中有A类的对象，那么创建B类对象时，先调用A的构造函数再调用B的，析构时先B的再A的;
      9. 赋值时，比如c1 = Cube(1, 1, 1);右边的临时对象创建后会直接调用析构函数。静态成员（public权限）和函数可以通过类名:: 和对象. 两种方法访问;
   3. 析构函数：~类名() {} 
      1. 没有返回值，也不用写void； 
      2. 函数名称与类名相同，在名称前加上符号~； 
      3. 析构函数不可以有参数，所以不能重载； 
      4. 程序在对象销毁前会自动调用析构函数，无需手动调用，而且只会调用一次。 
   4. C++对象模型和this指针 
      1. 类内的成员变量和成员函数分开存放，只有非静态成员变量才属于类的对象空间。每一个非静态成员函数只会诞生一份函数实例，多个对象公用这一块代码。 
      2. this指针指向被调用的成员函数所需的对象。当形参和成员变量同名时：this->age = age; 可以用于返回对象本身：return *this; 
      3. 常函数：成员函数后加const，比如：void get_value() const {…} // 此时不能修改成员属性，可以获取成员属性，当成员属性声明时加入mutable，在常函数中可以修改。常对象：声明对象前加const，比如：const class_type c; 此时该对象只能调用常函数。
   5. 友元函数：可以在类外访问类中的私有属性。全局函数、其他类和其他类中的成员函数都可以做友元。需要在被访问的类中添加函数声明：friend void googGay(class_type c); 
   6. 运算符重载：加号运算符重载、左移运算符重载、递增运算符重载、赋值运算符重载等。C++编译器至少给一个类添加了4个函数：（1）默认构造函数（无参，函数体为空）（2）默认析构函数（无参，函数体为空）（3）默认拷贝构造函数，对属性进行值拷贝（4）赋值运算符operate=，对属性进行值拷贝。无论是默认的拷贝构造函数还是赋值运算，只有存在指针（有属性指向堆区），就会出现深浅拷贝的问题。赋值运算符重载格式：Class_type& operate=(Class_type c) {…; return *this;} //把形参c的属性赋值给this对象后，返回 *this 
   7. 继承：可以减少重复的代码。 
      1. class A: public B{…};A类为子类或派生类，B类为父类或基类。 
      2. 继承中，先调用父类构造函数，再调用子类构造函数，析构顺序先子类再父类。 
      3. 当子类中出现和基类同名成员时，可以通过设定基类中该成员的属性为private来避免，也可以通过作用域来访问基类成员，比如：this->Base::a; 如果出现同名成员函数，子类会隐藏基类中同名成员函数，加作用域可以访问到父类同名函数。
      4. 菱形继承时，若要使公共的基类在派生类中只有一个拷贝，则可以将这种基类说明为虚基类。比如：class ClassName: virtual public ClassName{…};并且需要在子类的构造函数中直接调用基类的构造函数。 
   8. 多态 
      1. 静态多态：函数重载和运算符重载属于静态多态，复用函数名，静态多态的函数地址在编译阶段确定
      2. 动态多态：派生类和虚函数实现运行时多态；动态多态的函数地址在运行阶段确定 
   9. 有继承关系，子类中重写了父类中的虚函数：virtual void print(){…}，子类中不需要加关键字：void print(){…}。父类的指针指向子类对象，子类的对象可以用于初始化基类对象。 
   10. 多态中，通常父类的虚函数实现是没有意义的，主要是调用子类重写的内容，因此可以将父类的虚函数定义为纯虚函数：virtual < type > FuncName(< ArgList >) = 0; 把至少包含一个纯虚函数的类称为抽象类，这种类只能用于派生的基类，不能产生对象，但是可以产生基类指针，指向其派生类，调用派生类中重写的虚函数。实际使用时一般通过一个基类派生多个子类，每个子类重新实现虚函数，然后定义基类指针，指向某一个子类，则调用该类的虚函数。如果子类中在堆区开辟了空间，基类指针无法释放子类对象，可以在基类中用虚析构函数或者纯虚析构函数实现。 


